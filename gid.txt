Generic Image Decoder
---------------------

The Generic Image Decoder (GID) is an Ada package for decoding a
broad variety of image formats, from any data stream, to any kind
of medium, be it an in-memory bitmap, a GUI object,
some other stream, arrays of floating-point initial data
for scientific calculations, a browser element, a device,...
Animations are supported.

Some features:
- Standalone (no dependency on other libraires, bindings,...)
- Unconditionally portable code: OS-, CPU-, compiler- independent code.
- Multi-platform, but native code
- Task safe
- Endian-neutral
- Free, open-source
- pure Ada 95 (compiled by Ada 95, Ada 2005, and later compilers)

Some possible applications:
- a drawing program
- non-interactive image processing
- a web browser
- use of images as data for simulations
- image analysis, text recognition
- thumbnail generation for a file manager

Through the genericity and the use of the Inline pragma at multiple
nesting levels (see it like macros inside macros), the package is
able to deliver a decent decoding performance with a reasonably
compact and readable source code and without tediously copied
pieces of code with almost the same contents corresponding to
different subformats.

Licensing, warranty, copyright, supported formats, credits
----------------------------------------------------------
Please read the top comments in gid.ads.

How to use GID
--------------
Hopefully the package specification (in the file gid.ads) is self
explanatory enough. There are three steps needed:

1) Load the image header from a data stream
2) If needed, use dimensions to prepare the retrieval of the image
3) Load and decode the image itself. If the image is animated,
     call Load_image_contents until next_frame is 0.0

The subprograms corresponding to these steps are
1) Load_image_header
2) Pixel_width and Pixel_height 
3) Load_image_contents

Load_image_contents is generic. You provide the following:
  * Primary_color_range: the type of primary colors.
    Usually it is a byte (E.g. Unsigned_8)
  * procedure Set_X_Y: setting a "cursor" (an array index, for instance)
  * procedure Put_Pixel: set a color (and transparency on
      the "cursor" place; the cursor is meant to move one pixel
      to te right then
  * procedure Feedback: display progress (if you want it, otherwise
      you can provide an empty procedure)
  * mode: Display_mode: here tell if you want the decoding rather
      nicer or faster, when the decoder is processing "progressive"
      (JPEG) or "interlaced" (GIF, PNG) pictures. Note: the end
      result is exactly the same.

This generic construction allows you a total freedom on where and
how to use GID in your programs. In addition, your Set_X_Y and
Put_Pixel procedures are inserted and comple-time, not called,
right in the heart of the decoding procedures, for each image format,
which should deliver a decent performance as soon as you set the right
compiler options (optimization, inlined or macro-expanded generics,
suppression of all checks, loop unrolling).
     
Note on the construction of GID.
--------------------------------

All image formats decoded by GID have similarities in their structure.

- Most begin with a header containing dimensions and color depth,
  and the image contents follow. This is obvious to have such a data
  organisation, since the header details are needed to calibrate the
  recipient of the image. 

- They are structured in blocks, with different names depending on
  the format:
  - PNG : chunks
  - GIF : blocks
  - JPEG: segments
  - TGA : areas
  - TIFF: tags
  etc.

